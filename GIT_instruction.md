# Работа с Git 

## 1. Проверка наличия установленного Git
В терминале выполнить команду `git version`.

Если GIT установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию Git с сайта https://git-scm.com/download. Устанавливаем с настройками по умолчанию.

## 3. Настройка Git
При первом использовании Git необходимо представиться. Для этого в терминале нужно выполнить две команды:
```
...$ git config --global user.name «Ваше имя английскими буквами»
...$ git config --global user.email «Ваша_почта@example.com»
```

## 4. Создание репозитория
### 4.1. Инициализация отслеживания
Получить репозиторий можно двумя способами.
Сначала в терминале  перейдите в нужную папку, используя команду `cd <путь_до_нужной_папки>`. После этого выполнить более подходящую инструкцию.
1. Выполнить команду создания репозитория - `git init`
Git инициировал процесс отслеживания изменения файлов в указанной папке (и всех вложенных в нее) папке.
2. <a name="clone" style="color:#fff">Клонировать</a> существующий репозиторий Git из любого места. Сделать это можно следующим образом:
```
git clone <адрес репозитория>
```
### 4.2. Включение папок и файлов в отслеживаемые
После этого нужно конкретно указать, какие именно файлы вы хотите добавить к отслеживаемым. В этом помогут команды `git add <имя_файла>` или `git add .` (добавит все папки и файлы в отслеживаемые).

```
#Добавление всех файлов в отслеживаемые
...$ git add .

#Добавление конкретного файлв в отслеживаемые
...$ git add <имя_файла> 
```
### 4.3. Исключение файлов или папок из отслеживаемых
Для того, чтобы исключить какие-либо папки и файлы из отслеживаемых, нужно в корневой папке проекта (где инициирован процесс отслеживания) создать специальный файл `.gitignore`. Git автоматически считывает содержимое этого файла и исключает из отслеживания те файлы и папки, которые там указаны (папки виртуального окружения, логи работы локального сервера, логи тестирования и т.п.).

```
.tox/
.nox/
.coverage
.coverage.*
.cache
.DS_Store
```

Посмотреть, какие файлы и папки игнорируются, можно командой `git status --ignored`.
### 4.4. Фиксация состояния отслеживаемой папки
После того, как вы добавили и исключили выбранные папки и файлы, вам нужно зафиксировать текущее состояние проекта.
Это делает команда `git commit`. 
После ее ввода терминал будет ожидать введения комментария в выбранном по умолчанию текстовом редакторе терминала. Чтобы этого избежать, вы можете использовать флаг `-m` и ввести описание состояния вместе с командой `git commit` - `git commit -m "<комментарий>"`

```
...$ git commit -m "<комментарий>"
```

Отлично! Нужные файлы и папки добавлены, ненужные исключены, состояние зафиксировано и описано. Или "закоммичены". Последнее зафиксированное состояние файлов и папок традиционно называется "последний коммит".

Вы можете использовать эту команду сколь угодное количество раз, однако правилом хорошего тона считается фиксация каких-то существенных изменений (добавление/удаление файлов, добавление функций, изменение логики и т.п.) и их лаконичное и конкретное описание (желательно на английском языке):

```
...$ git commit -m "file 'settings.py' added"
...
...$ git commit -m "class User created"
```

> Если в отслеживаемом проекте не добавлялись новые файлы или папки, внесенные изменения можно одновременно добавить и закоммитить одной командой - `git add` с флагом `-a`:
```
...$ git add -a -m "<ваш комментарий>"
```
Флаги можно писать слитно:
```
...$ git add -am "<ваш комментарий>"
```

## 5. Проверка состояния файлов и папок в последнем коммите 
После того, как вы научились фиксировать состояние файлов и папок своего проекта, будет здорово научиться их сравнивать и перемещаться между этими состояниями.
### 5.1. Проверка перечня добавленных папок и файлов
Для проверки того, какие папки и файлы добавлены в последний коммит, есть команда `git status`. 
Она выведет и подсветит зеленым отслеживаемые папки и файлы, красным - неотслеживаемые (их надо будет либо добавить через команду `git add <имя_файла>`, либо исключить, вписав их в файл `.gitignore`).
```
... $ git status

On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   .gitignore
        modified:   GIT_instruction.md

```
Итак, команда `git status` позволит отследить, не забыли ли вы сохранить и зафиксировать то или иное состояние файлов проекта. 
> Команда `git status -s` выведет статус вашего проекта в сокращенном состоянии - не вернет ничего, если все файлы и содержимое закоммичено, или наоборот покажет статус и название файла с незакомиченными изменениями (если изменения не закоммичены).
### 5.2. Проверка разницы в состояниях файлов (последнее зафиксированное vs текущее)
Фиксировать состояние содержимого отслеживаемых файлов очень удобно с помощью команды `git diff`. 
Если вы в процессе работы вдруг потеряете нить, что-то удалите и забудете что именно,  или же просто захотите увидеть разницу между последним коммитом и текущем состояниием ***содержимого*** файлов, используйте команду эту команду - `git diff`. Она выведет и подсветит все изменения в содержимом отслеживаемых файлов.

Что ж, мы с вами узнали, как правильно коммитить свой проект, как узнавать состояние разницу межджу коммитами и в содержимом файлов. Теперь будет полезно узнать, как перемещаться между коммитами (да, Git умеет и такое!).

```
...$ git diff
diff --git a/GIT_instruction.md b/GIT_instruction.md
index 94d08a3..3ff0270 100644
--- a/GIT_instruction.md
+++ b/GIT_instruction.md
@@ -53,12 +53,48 @@ git add <имя_файла>
 git commit -m "<комментарий>"
 ```

### 5.3. Просмотр сделанных коммитов
Команда `git log` выведет список всех сделанных коммитов с датой и комментарием. Это очень удобно и пригодится нам для перемещения между состояними.

```
...$ git log
commit 728893077395d661bb9e5ee85f9f500479a068a9 (HEAD -> main)
Author: Name Surname <your_mail@example.com>
Date:   Sun Dec 4 22:06:48 2022 +0300

    few chapters added

commit 0bfe65d96cb8d09da4137c077867a202d5bd3e0f
Author: Name Surname <your_mail@example.com>
```
>1. Для того, чтобы вывести логи в одну строку, нужно добавить аргумент `--oneline` - будет выведен перечень всех коммитов построчно, 7 первых символов коммита и комментарий в каждой строчке.
>2. Для того, чтобы вывести несколько последних коммитов, можно добавить аргумент `-n`, где `n` - количество последних коммитов. Терминал вернет `n`-ное количество последних коммитов.
## 6. Перемещение между состояниями (коммитами), слияние и удаление веток
Итак, теперь мы научимся перемещаться между состояниями своего проекта. Это осуществляется командой `git checkout <первые_4+_символа_коммита>`. После ввода этой команды наш проект перейдет в то состояние, которое мы зафиксировали в момент создания определенного коммита.

 > Этот переход может действительно напугать! :) Особенно неопытного разработчика. Потому что у вас ***физически*** пропадут все файлы, папки и изменения проекта. Но как говорится ничего страшного - вы в любой момент сможете вернуться к любому созданному коммиту, в том числе к последнему. Таким образом, все изменения будут в целости и сохранности - главное не забывать их делать по ходу работы. 
 >
 >Но даже если вы их забудете сделать, Git  не позволит вам просто прыгнуть в прошлое и потерять последние изменения - он выдаст соответствующее предупреждение:
 > ```
 >...$ git checkout 72ddcc3
>error: Your local changes to the following files would be overwritten by checkout:
>        GIT_instruction.md
>Please commit your changes or stash them before you switch branches.
>Aborting
> ```
>
 
 Так же вы можете вернуться к последнему состоянию командой `git switch master` или `git switch main` - о правильном названии главной ветки Git сообщит вам, например, после введения команды `git log --oneline` в строчке последнего коммита - HEAD -> тут_будет_название:
```
... $ git log --oneline
f56c4e9 (HEAD -> main) 6 chapter added
d308cb9 5.3 chapter added
7288930 few chapters added
0bfe65d Chapter 3 added
df4d6ba Second chapter added
72ddcc3 Dot added
```
### 6.1. Ветвление состояний

Перемещение в конкретный коммит может быть нужно для того, чтобы создать новую хронологическую ветку изменений. Например, вы захотите протестировать работу определенной функции двумя способами. Тогда из определенного коммита вы можете создать две полноценные, параллельные друг другу "дорожки" коммитов, которые будут вести в разные состояния вашего проекта.

Чтобы не запутаться в своих перемещениях, существует команда `git reflog`. Она покажет перемещение вашей ***метки HEAD***, то есть выведет полную хронологию перемещения вашего внимания по всем коммитам проекта. Вы увидите не только сделанные коммиты, но и все ваши перемещения в "прошлое", другие коммиты и альтернативные ветки. Таким образом вы никогда не заблудитесь и всегда сможете вернуться в нужное вам состояние.

>В процессе работы история версий вашего проекта быстро станет внушительной. При выводе результатов команд в терминал в последней строчке вы можете увидеть двоеточие - так терминал сообщает о том, что он вывел не все данные:
>
>![colon in terminal](./img/colon_terminal.jpeg)
>Вы можете прокручивать результаты стролочкой на клавиатуре (постепенно) или пробелом (по несколько штук).
> В конце терминал выведет `(END)`:
>![screenshot of the "(END)" in terminal](./img/end_terminal.jpeg)
>Для вывода терминала из этого состояния в любой момент можно нажать `q` на клавиатуре (не забудьте перевести раскладку в английскую - с русской не сработает).

Однако с дальнейшим ростом проекта разобраться в хронологии перемещения тоже становится очень непросто. Git снова приходит на помощь! :) 

Помимо указания коммитов, Git позволяет создать триггерную точку - поставить большой "указатель" в том месте, где наши коммиты пойдут другим путем. Речь о создании новой ветки - `git branch <имя_ветки>`

```
... $ git branch new_branch
```

После создания ветки командой `git branch` можно вывести список всех имеющихся в проекте веток. Активная будет подсвечена зеленым и обозначена звездочкой (*).

После создания ветки нужно в нее переместиться командой `git checkout new_branch`
```
... $ git checkout new_branch
```
Профит! Теперь нам не нужно искать в списке коммитов место, где мы решили создать дополнительные варианты развития проекта - все будет удобно укомплектовано в обозначенных ветках.

### 6.2. Слияние веток

Чтобы выполнить слияние двух веток коммитов, сначала нам нужно перейти в ту ветку, _к которой_ мы хотим добавить другую ветку (в главную из двух) - `git checkout main`, и после выполняем  команду `git merge <имя_ветки>`. Все изменения файлов, проведенные в ветке `<имя_ветки>`, будут добавлены к ветке, которая была активна в момент ввода команды `git merge <имя_ветки>`.
```
... $ git chechout main
Switched to branch 'main'
... $ git merge images
Updating fe7fd5e..6c7ff1d
Fast-forward
 .gitignore              | 2 ++
 Markdown instruction.md | 2 ++
 2 files changed, 4 insertions(+)
 create mode 100644 .gitignore
```
Ура! Мы успешно присоединили вторую ветку к первой.

### 6.3. Удаление веток

После того, как мы слили ветки, в случае, если вторая ветка нам больше не нужна, мы можем удалить ее командой `git branch -d <имя_ветки>`. Эта команда так же должна вводиться из главной ветки.

```
... $ git branch -d images
Deleted branch images (was 6c7ff1d).
```

Все, вторая ветка удалена.
>Логи сделанных коммитов с ветвлением позволяет увидеть команда `git log --graph`

### 6.4. Разрешение конфликтов

В процессе слияния двух веток может возникнуть конфликт. Например, если после начала ветвления состояние основной ветки было изменено. Скриним файл для этого раздела! 🙂
![conflict demonstration](./img/conflict.jpeg)
На выбор предоставляется четыре варианта:
1. Accept Current Change

    Принять текущие изменения. Или оставить тот вариант, который был в главной ветке (к которой мержили второстепенную). 
2. Accept Incoming Change

    Принять входящие изменения - будет принят тот вариант, который предлагает добавляемая ветка (второстепенная).
3. Accept Both Changes

    Принять оба изменения - тот вариант, который выбрали мы. Он оставит оба варианта редактирования, _оставив в приоритете главную ветку_ - изменения в тексте, присутствовашие в главном файле, будут выше добавляемых из второстепенной ветки.
4. Compare Changes

    Сравнить разницу. Подсветятся места, которые в ветках не совпадают.

# Работа с удаленными репозиториями

Мы разобрались с работой в локальном репозитории. Теперь при желании мы сможем обмениваться этой папкой с другими людьми и проводить совместную работу.

Нам на радость наши коллеги уже позаботились об этом и создали удобные сервисы. Мы будем работать с Github.

> &nbsp;
> 
> Важно разделять Git - систему контроля версий - от сервисов для работы с ней (Github, GitLab, Bitbucket и другие). Последние - это удобные расширения и сервисы, делающие работу с Git более удобной и прикладной, и позволяет организовать работу с удаленными репозиторями. Мы будем работать с самым популярным сервисом - Github, и все дальнейшие инструкции будем давать именно для него.
>
> &nbsp;

Что нам нужно сделать:

1. Зарегистрироваться на https://github.com/
2. Создать локальный репозиторий
3. Связать удаленный репозиторий с локальным.

Разберемся по шагам.

## 1. Регистрация на ГитХаб

Тут ничего сложного, все традиционно. Вводим почту, получаем на нее пароль, профит!

## 2. Создать локальный репозиторий

Если вы двигаетесь по инструкции пошагово, локальный репозиторий у вас уже создан. Если нет - просмотрите шаги и создайте.

## 3. Создать удаленный репозиторий

Сначала нам нужно создать удаленный репозиторий через веб-версию Гитхаб. Есть способы его создания и через консоль, но давайте для простоты пока остановимся варианте создания через веб.
Входим в свой аккаунт, переходим на вкладку `Repositories` и жмем зеленую кнопку `New`. Вводим имя репозитория (оно может быть любым), больше (опять же для простоты) ничего не меняем и жмем зеленую кнопку `Create repository`.

## 4. Связка локального и удаленного репозитория

Теперь нам нужно связать два репозитория между собой. После создания репозитория Github сам вам подскажет, что делать. А делать нужно следующее:

1. Перейти в корневую папку проекта (ту самую, в которой мы инициировали создание локального репозитория командой `git init`) 

2. Связываем репозитории следующей командой: 
```
... $ git remote add origin <ссылка_на_наш_проект>
```
Давайте сразу проясним, что мы тут просим сделать:
- `remote` - переводится как "удаленный". Этим аргументом мы указываем Git, что собираемся работать с удаленным репозиторием
- `add` - "добавить" - тут все понятно. Добавляем текущий проект к удаленному.
- `origin` - название, которое мы даем репозиторию

3. Даем название нашей ветке.

Если это главная ветка проекта, можем назвать ее `main` или `master`. В иных случаях давайте ветке подходящее название.

```
... $ git branch -M main
```

4. Отправляем локальные файлы и коммиты на удаленный репозиторий

```
... $ git push -u origin main
```

Если вы делаете это в первый раз, Git попросит вас авторизоваться через веб. Приложение попросит добавить его в доверенные - смело разрешаем. 

И на этом все, ура-ура! Удаленный репозиторий получил все файлы и коммиты нашего локального репозитория.

>  &nbsp;
> 
>Для того, чтобы сменить удаленный репозиторий, нужно ввести команду 
> ```
> ... $ git remote set-url origin <ссылка_на_новый_проект>
> ```
> Проверить, изменился ли проект, можно командой
> ```
> ... $ git remote -v
> ```
>
> Терминал выведет ссылку на актуальный удаленный репозиторий, ассоциированный с локальным проектом.
>  &nbsp;

## 5. Совместная работа над open-source репозиториями других авторов

Github богат на проекты, которые готовы принимать помощь от других разработчиков - так называемые open-source проекты. Вы можете скачать себе текущий вариант какого-либо сервиса, программы или другой информационной единицы с Гитхаб и предложить свое участие. Давайте разберемся, как это делать.

Для простоты рассмотрим вариант, когда ваша работа над проектом начинается со скачивания текущей версии проекта - то есть в нашем локальном репозитории не будет коммитов, созданных *до* скачивания удаленного репо.

Итак, инструкция:

1. Делаем `Fork` проекта

Если мы хотим не просто скачать проект, но и привязаться к нему - что нам собственно и нужно - команда `git clone <адрес проекта>` нам не подходит. 

Мы должны сделать `fork` проекта, к которому хотим присоединиться - это делается в веб-интерфейсе Github. Переходим в проект, который нас интересует, и в правой верхней части верхнего меню ищем кнопку `Fork`. Жмем и после подтверждаем создание репозитория, нажав зеленую кнопку `Create repository`.

Теперь в нашем аккаунте на Гитхаб есть форк нужного нам репозитория.

2. Клонируем удаленный репозиторий

Эта операция нам [уже знакома](#clone) 
[Custom foo gfgdescription](#-4.1.-Инициализация-отслеживания)

### 3.1. Связка локального репозитория путем клонирования и замены файла
